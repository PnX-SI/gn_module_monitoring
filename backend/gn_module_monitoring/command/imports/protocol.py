import os
from gn_module_monitoring.config.utils import (
    json_from_file,
    monitoring_module_config_path,
    json_config_from_file,
)
from gn_module_monitoring.command.imports.entity import (
    get_entities_protocol,
    get_entity_parent,
    insert_entities,
    insert_entity_field_relations,
    update_entity_label,
)
from gn_module_monitoring.command.imports.fields import (
    delete_bib_fields,
    get_field_name,
    has_field_changes,
    insert_bib_field,
    prepare_fields,
)
from gn_module_monitoring.command.imports.sql import create_sql_import_table_protocol
from sqlalchemy import select


from geonature.utils.env import DB
from geonature.core.imports.models import (
    BibFields,
    Destination,
    Entity,
)


def get_protocol_data(module_code: str, id_destination: int):
    """
    Construit les données du protocole à partir des fichiers JSON spécifiques et génériques.

    Parameters
    ----------
    entities : list
        Liste des entités du module.
    module_code : str
        Code du module.
    id_destination : int
        ID de la destination dans bib_destinations.

    Returns
    -------
    tuple
        Données du protocole et mapping des colonnes des entités.
    """
    protocol_data = {}
    entity_hierarchy_map = {}
    module_config_dir_path = monitoring_module_config_path(module_code)
    entities = get_entities_protocol(module_code)

    module_config_path = module_config_dir_path / "config.json"
    module_config = json_from_file(module_config_path)
    tree = module_config.get("tree", {}).get("module", {})

    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

    entity_confs = {}
    # Ensure all confs are loaded in a dict
    for entity_code in entities:
        file_path = module_config_dir_path / f"{entity_code}.json"
        specific_data = json_from_file(file_path)

        generic_data = json_config_from_file("generic", entity_code)

        entity_confs[entity_code] = {
            "specific_data": specific_data,
            "generic_data": generic_data,
        }

    # Now we can iterate safetly over confs
    for entity_code in entity_confs:
        entity_conf = entity_confs[entity_code]
        parent_entity = get_entity_parent(tree, entity_code)
        specific_data = entity_conf["specific_data"]
        generic_data = entity_conf["generic_data"]
        id_field_name = generic_data.get("id_field_name")

        entity_hierarchy_map[entity_code] = {
            "id_field_name": id_field_name,
            "parent_entity": parent_entity,
        }
        parent_data = entity_confs.get(parent_entity, None)
        protocol_data[entity_code] = prepare_fields(
            specific_data, generic_data, entity_code, id_destination, parent_data
        )

    entities_with_geom = ["site"]
    if "sites_group" in entities:
        entities_with_geom.append("sites_group")

    for entity_code in entities_with_geom:
        entity_conf = entity_confs[entity_code]
        generic_data = entity_conf.get("generic_data")
        specific_data = entity_conf.get("specific_data")
        geom_field_name = specific_data.get("geom_field_name", generic_data.get("geom_field_name"))
        if geom_field_name is not None:
            name_field = get_field_name(entity_code, geom_field_name)
            protocol_data[entity_code]["generic"].extend(
                [
                    {
                        "name_field": name_field,
                        "fr_label": "Géometrie (WKT)",
                        "type_field": "textarea",
                        "type_column": "text",
                        "mandatory": True,
                        "autogenerated": False,
                        "display": True,
                        "source_field": f"src_{name_field}",
                        "multi": False,
                        "id_destination": id_destination,
                    },
                    {
                        "name_field": f"{name_field}_4326",
                        "fr_label": "Géométrie (SRID 4326)",
                        "type_field": "textarea",
                        "type_column": "geometry_4326",
                        "mandatory": False,
                        "autogenerated": False,
                        "display": False,
                        "dest_field": name_field,
                        "multi": False,
                        "id_destination": id_destination,
                    },
                    {
                        "name_field": f"{name_field}_local",
                        "fr_label": "Géométrie (SRID local)",
                        "type_field": "textarea",
                        "type_column": "geometry_local",
                        "mandatory": False,
                        "autogenerated": False,
                        "display": False,
                        "dest_field": f"{name_field}_local",
                        "multi": False,
                        "id_destination": id_destination,
                    },
                ]
            )

    for name in ["site", "visit", "observation"]:
        if name not in entities:
            continue
        suffix = name if name == "observation" else f"base_{name}"
        protocol_data[name]["generic"].extend(
            [
                {
                    "name_field": f"id_{suffix}",
                    "fr_label": f"ID {suffix}",
                    "type_field": "text",
                    "type_column": "integer",
                    "mandatory": False,
                    "autogenerated": True,
                    "display": False,
                    "source_field": f"src_id_{suffix}",
                    "dest_field": f"id_{suffix}",
                    "multi": False,
                    "id_destination": id_destination,
                },
                {
                    "name_field": f"uuid_{suffix}",
                    "fr_label": f"UUID {suffix}",
                    "type_field": "text",
                    "type_column": "uuid",
                    "mandatory": False,
                    "autogenerated": False,
                    "display": True,
                    "source_field": f"src_uuid_{suffix}",
                    "dest_field": f"uuid_{suffix}",
                    "multi": False,
                    "id_destination": id_destination,
                },
            ]
        )

    protocol_data["visit"]["generic"].extend(
        [
            {
                "name_field": "id_dataset",
                "fr_label": "Identifiant JDD",
                "type_field": "textarea",
                "type_column": "integer",
                "mandatory": False,
                "autogenerated": False,
                "display": False,
                "dest_field": "id_dataset",
                "multi": False,
                "id_destination": id_destination,
            },
            {
                "name_field": "unique_dataset_id",
                "fr_label": "Identifiant JDD (UUID)",
                "type_field": "dataset",
                "type_column": "varchar",
                "mandatory": True,
                "autogenerated": False,
                "display": True,
                "source_field": "src_unique_dataset_id",
                "multi": False,
                "id_destination": id_destination,
                "type_field_params": {"bind_value": "unique_dataset_id"},
            },
        ]
    )

    # Add observation_detail if exists the file exists
    if "observation" in entities:
        observation_detail_specific_path = module_config_dir_path / "observation_detail.json"
        observation_detail_generic_path = os.path.join(
            project_root, "config", "generic", "observation_detail.json"
        )

        if observation_detail_specific_path.exists():
            specific_data = json_from_file(observation_detail_specific_path)
            generic_data = json_from_file(observation_detail_generic_path, result_default={})
            entity_hierarchy_map["observation_detail"] = {
                "id_field_name": generic_data.get("id_field_name"),
                "parent_entity": "observation",
            }
            parent_data = entity_confs.get("observation", None)
            protocol_data["observation_detail"] = prepare_fields(
                specific_data, generic_data, "observation_detail", id_destination, parent_data
            )

    return protocol_data, entity_hierarchy_map


def get_existing_protocol_state(id_destination: int, module_data):
    """
    Récupère l'état actuel du protocole en base de données.
    """
    fields_query = select(BibFields).filter_by(id_destination=id_destination)
    existing_fields = DB.session.execute(fields_query).scalars().all()

    entities_query = select(Entity).filter_by(id_destination=id_destination)
    existing_entities = DB.session.execute(entities_query).scalars().all()

    destination = DB.session.execute(
        select(Destination).filter_by(id_destination=id_destination)
    ).scalar()
    new_label = module_data["module"].get("module_label")
    return {
        "fields": [field.__dict__ for field in existing_fields],
        "entities": [entity.__dict__ for entity in existing_entities],
        "label": True if destination and destination.label != new_label else False,
    }


def update_protocol(module_data, module_code, fields_to_delete, update_label_only=False):
    """
    Met à jour un protocole existant ou uniquement le libellé de l'entité dans `bib_entities`.

    Args:
        module_data: Données du module à mettre à jour.
        module_code: Code du module.
        fields_to_delete: Liste des champs à supprimer.
        update_label_only: Si vrai, met à jour uniquement le label de l'entité.

    Returns:
        Booléen indiquant si la mise à jour a réussi.
    """
    try:
        DB.session.rollback()
        module_label = module_data["module"].get("module_label")

        destination = DB.session.execute(
            select(Destination).filter_by(code=module_code)
        ).scalar_one()

        if update_label_only:
            update_entity_label(destination.id_destination, module_label)
            DB.session.commit()
            return True

        protocol_data, entity_hierarchy_map = get_protocol_data(
            module_code, destination.id_destination
        )

        with DB.session.begin_nested():

            insert_bib_field(protocol_data)

            insert_entities(
                protocol_data,
                destination.id_destination,
                entity_hierarchy_map,
                module_code=module_code,
            )

            insert_entity_field_relations(
                protocol_data, destination.id_destination, entity_hierarchy_map
            )

            if fields_to_delete:
                delete_bib_fields(fields_to_delete)

            table_name = f"t_imports_{module_code.lower()}"
            DB.engine.execute(f"DROP TABLE IF EXISTS gn_imports.{table_name}")

            create_sql_import_table_protocol(module_code, protocol_data)

        DB.session.commit()
        return True

    except Exception as e:
        DB.session.rollback()
        print(f"Erreur lors de la mise à jour du protocole : {str(e)}")
        return False


def compare_protocol_fields(existing_fields, new_fields):
    """
    Compare les champs existants avec les nouveaux champs pour identifier les différences.

    Args:
        existing_fields: Liste des champs existants en base
        new_fields: Liste des nouveaux champs depuis les fichiers JSON

    Returns:
        - Liste des champs à ajouter
        - Liste des champs à mettre à jour
        - Liste des champs à supprimer
    """
    existing_by_name = {f["name_field"]: f for f in existing_fields}
    new_by_name = {f["name_field"]: f for f in new_fields}

    to_add = []
    to_update = []
    to_delete = []

    for name, new_field in new_by_name.items():
        if name not in existing_by_name:
            to_add.append(new_field)
        else:
            existing = existing_by_name[name]
            if has_field_changes(existing, new_field):
                to_update.append(new_field)

    for name in existing_by_name:
        if name not in new_by_name:
            to_delete.append(existing_by_name[name])

    return to_add, to_update, to_delete
